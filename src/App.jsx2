import React, { useEffect, useRef, useState } from 'react';
// import * as THREE from 'three';
import * as THREE from 'three/webgpu'
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import WebGPU from 'three/addons/capabilities/WebGPU.js';
import { WebGPURenderer } from 'three/webgpu';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';

export default function App() {
  const containerRef = useRef(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [jsonInput, setJsonInput] = useState('');

  // Default comprehensive scene
  const defaultScene = {
    "X3D": {
      "version": "3.3",
      "profile": "Immersive",
      "Scene": {
        "children": [
          {
            "Background": {
              "DEF": "MainBackground",
              "skyColor": [[0.0, 0.2, 0.7], [0.0, 0.5, 1.0], [1.0, 1.0, 1.0]],
              "skyAngle": [1.309, 1.571],
              "groundColor": [[0.1, 0.1, 0.0], [0.4, 0.25, 0.2], [0.6, 0.6, 0.6]],
              "groundAngle": [1.309, 1.571]
            }
          },
          {
            "Fog": {
              "color": [0.8, 0.8, 0.9],
              "fogType": "LINEAR",
              "visibilityRange": 50
            }
          },
          {
            "DirectionalLight": {
              "DEF": "SunLight",
              "direction": [0, -1, -1],
              "color": [1, 1, 0.9],
              "intensity": 0.8
            }
          },
          {
            "PointLight": {
              "DEF": "RedLight",
              "location": [5, 3, 5],
              "color": [1, 0.2, 0.2],
              "intensity": 0.6
            }
          },
          {
            "SpotLight": {
              "DEF": "SpotLight1",
              "location": [-5, 5, 5],
              "direction": [1, -1, -1],
              "color": [0.2, 0.2, 1],
              "intensity": 0.7,
              "angle": 0.78
            }
          },
          {
            "Transform": {
              "DEF": "BoxTransform",
              "translation": [-8, 1, 0],
              "rotation": [0, 1, 0, 0.785],
              "children": [
                {
                  "Shape": {
                    "geometry": {"Box": {"size": [2, 2, 2]}},
                    "appearance": {
                      "Appearance": {
                        "material": {
                          "Material": {
                            "DEF": "RedMaterial",
                            "diffuseColor": [1, 0.2, 0.2],
                            "specularColor": [1, 1, 1],
                            "emissiveColor": [0.1, 0, 0],
                            "shininess": 0.8
                          }
                        }
                      }
                    }
                  }
                },
                {"TouchSensor": {"DEF": "BoxTouch"}}
              ]
            }
          },
          {
            "Transform": {
              "translation": [-4, 1.5, 0],
              "children": [{
                "Shape": {
                  "geometry": {"Sphere": {"radius": 1.5}},
                  "appearance": {
                    "Appearance": {
                      "material": {
                        "Material": {
                          "diffuseColor": [0.2, 1, 0.2],
                          "transparency": 0.3
                        }
                      }
                    }
                  }
                }
              }]
            }
          },
          {
            "Transform": {
              "translation": [0, 1, 0],
              "children": [{
                "Shape": {
                  "geometry": {"Cone": {"height": 3, "bottomRadius": 1.5}},
                  "appearance": {"Appearance": {"material": {"Material": {"diffuseColor": [0.2, 0.2, 1]}}}}
                }
              }]
            }
          },
          {
            "Transform": {
              "translation": [4, 1, 0],
              "rotation": [1, 0, 0, 1.57],
              "children": [{
                "Shape": {
                  "geometry": {"Cylinder": {"height": 3, "radius": 1}},
                  "appearance": {"Appearance": {"material": {"Material": {"diffuseColor": [1, 1, 0.2]}}}}
                }
              }]
            }
          },
          {
            "Transform": {
              "translation": [8, 1, 0],
              "children": [{
                "Shape": {
                  "geometry": {"Torus": {"outerRadius": 1.5, "innerRadius": 0.5}},
                  "appearance": {"Appearance": {"material": {"Material": {"diffuseColor": [1, 0.5, 0.2]}}}}
                }
              }]
            }
          },
          {
            "Transform": {
              "translation": [0, 0, -5],
              "children": [{
                "Shape": {
                  "geometry": {
                    "IndexedFaceSet": {
                      "coord": {
                        "Coordinate": {
                          "point": [[0, 2, 0], [-1, 0, 1], [1, 0, 1], [1, 0, -1], [-1, 0, -1]]
                        }
                      },
                      "coordIndex": [0, 1, 2, -1, 0, 2, 3, -1, 0, 3, 4, -1, 0, 4, 1, -1, 1, 4, 3, 2, -1],
                      "colorPerVertex": false,
                      "color": {
                        "Color": {
                          "color": [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [0.5, 0.5, 0.5]]
                        }
                      },
                      "colorIndex": [0, 1, 2, 3, 4]
                    }
                  },
                  "appearance": {"Appearance": {"material": {"Material": {"diffuseColor": [0.8, 0.8, 0.8]}}}}
                }
              }]
            }
          },
          {
            "Transform": {
              "translation": [0, 3, 5],
              "children": [{
                "Shape": {
                  "geometry": {
                    "IndexedLineSet": {
                      "coord": {
                        "Coordinate": {
                          "point": [[-2, 0, 0], [2, 0, 0], [0, 0, -2], [0, 0, 2], [0, -2, 0], [0, 2, 0]]
                        }
                      },
                      "coordIndex": [0, 1, -1, 2, 3, -1, 4, 5, -1],
                      "colorPerVertex": true,
                      "color": {
                        "Color": {
                          "color": [[1, 0, 0], [1, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1], [0, 0, 1]]
                        }
                      }
                    }
                  }
                }
              }]
            }
          },
          {
            "Transform": {
              "translation": [-8, 0, -5],
              "children": [{
                "Shape": {
                  "geometry": {
                    "PointSet": {
                      "coord": {
                        "Coordinate": {
                          "point": [[0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1]]
                        }
                      },
                      "color": {
                        "Color": {
                          "color": [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1], [0.5, 0.5, 0.5]]
                        }
                      }
                    }
                  }
                }
              }]
            }
          },
          {
            "Billboard": {
              "DEF": "TextBillboard",
              "children": [{
                "Transform": {
                  "translation": [0, 6, 0],
                  "children": [{
                    "Shape": {
                      "geometry": {
                        "Text": {
                          "string": ["X3D Complete", "WebGPU Renderer"],
                          "fontStyle": {"FontStyle": {"size": 0.8}}
                        }
                      },
                      "appearance": {
                        "Appearance": {
                          "material": {"Material": {"diffuseColor": [1, 1, 0], "emissiveColor": [0.5, 0.5, 0]}}
                        }
                      }
                    }
                  }]
                }
              }]
            }
          },
          {
            "TimeSensor": {
              "DEF": "Clock",
              "cycleInterval": 5,
              "loop": true,
              "enabled": true
            }
          },
          {
            "PositionInterpolator": {
              "DEF": "BoxMover",
              "key": [0, 0.25, 0.5, 0.75, 1],
              "keyValue": [[-8, 1, 0], [-8, 3, 0], [-8, 1, 0], [-8, -1, 0], [-8, 1, 0]]
            }
          },
          {
            "OrientationInterpolator": {
              "DEF": "BoxRotator",
              "key": [0, 0.5, 1],
              "keyValue": [[0, 1, 0, 0], [0, 1, 0, 3.14159], [0, 1, 0, 6.28318]]
            }
          },
          {
            "ColorInterpolator": {
              "DEF": "ColorChanger",
              "key": [0, 0.33, 0.66, 1],
              "keyValue": [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 0]]
            }
          },
          {
            "ROUTE": {
              "fromNode": "Clock",
              "fromField": "fraction_changed",
              "toNode": "BoxMover",
              "toField": "set_fraction"
            }
          },
          {
            "ROUTE": {
              "fromNode": "BoxMover",
              "fromField": "value_changed",
              "toNode": "BoxTransform",
              "toField": "set_translation"
            }
          },
          {
            "ROUTE": {
              "fromNode": "Clock",
              "fromField": "fraction_changed",
              "toNode": "BoxRotator",
              "toField": "set_fraction"
            }
          },
          {
            "ROUTE": {
              "fromNode": "BoxRotator",
              "fromField": "value_changed",
              "toNode": "BoxTransform",
              "toField": "set_rotation"
            }
          },
          {
            "ROUTE": {
              "fromNode": "Clock",
              "fromField": "fraction_changed",
              "toNode": "ColorChanger",
              "toField": "set_fraction"
            }
          },
          {
            "ROUTE": {
              "fromNode": "ColorChanger",
              "fromField": "value_changed",
              "toNode": "RedMaterial",
              "toField": "set_diffuseColor"
            }
          }
        ]
      }
    }
  };

  useEffect(() => {
    setJsonInput(JSON.stringify(defaultScene, null, 2));
  }, []);

  useEffect(() => {
    if (!jsonInput) return;

    if (!WebGPU.isAvailable()) {
      setError('WebGPU is not supported in your browser. Please use Chrome/Edge 113+');
      setLoading(false);
      return;
    }

    let renderer, scene, camera, controls, clock;
    const defRegistry = new Map();
    const routes = [];
    const timeSensors = [];
    const interpolators = [];
    const billboards = [];
    const routeUpdates = []; // Array to store per-frame update functions

    const init = async () => {
      try {
        setLoading(true);

        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        clock = new THREE.Clock();

        // Create camera
        camera = new THREE.PerspectiveCamera(
          60,
          containerRef.current.clientWidth / containerRef.current.clientHeight,
          0.1,
          1000
        );
        camera.position.set(5, 5, 20);

        // Create WebGPU renderer
        renderer = new WebGPURenderer({ antialias: true });
        await renderer.init();
        renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Clear previous canvas and append new one
        if (containerRef.current) {
          containerRef.current.innerHTML = '';
          containerRef.current.appendChild(renderer.domElement);
        }

        // Add orbit controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        // Parse and render X3D JSON
        const x3dData = JSON.parse(jsonInput);
        await parseX3DJSON(x3dData, scene);

        // Process routes after all nodes are created
        processRoutes();

        // Animation loop
        const animate = () => {
          const deltaTime = clock.getDelta();
          const elapsedTime = clock.getElapsedTime();

          // Update time sensors
          timeSensors.forEach(sensor => {
            if (sensor.enabled && sensor.loop) {
              const fraction = (elapsedTime % sensor.cycleInterval) / sensor.cycleInterval;
              sensor.fraction_changed = fraction;
            }
          });

          // Execute route updates
          routeUpdates.forEach(fn => fn());

          // Update billboards
          billboards.forEach(billboard => {
            billboard.lookAt(camera.position);
          });

          controls.update();
          renderer.render(scene, camera);
        };

        // WebGPURenderer requires setAnimationLoop
        renderer.setAnimationLoop(animate);

        // Handle window resize
        const handleResize = () => {
          if (!containerRef.current) return;
          camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
        };
        window.addEventListener('resize', handleResize);

        setLoading(false);
        setError(null);

        return () => {
          window.removeEventListener('resize', handleResize);
          if (renderer) {
            renderer.setAnimationLoop(null);
            renderer.dispose();
            if (containerRef.current?.contains(renderer.domElement)) {
              containerRef.current.removeChild(renderer.domElement);
            }
          }
        };
      } catch (err) {
        setError(`Error: ${err.message}`);
        setLoading(false);
      }
    };

    const parseX3DJSON = async (x3dData, scene) => {
      if (x3dData.X3D && x3dData.X3D.Scene) {
        await parseNode(x3dData.X3D.Scene, scene);
      }
    };

    const parseNode = async (node, parent) => {
      if (node.children) {
        for (const child of node.children) {
          await parseChild(child, parent);
        }
      }
    };

    const parseChild = async (child, parent) => {
      // Handle DEF
      const def = child.DEF || Object.values(child)[0]?.DEF;

      if (child.Transform) {
        const transform = createTransform(child.Transform);
        parent.add(transform);
        if (child.Transform.DEF) defRegistry.set(child.Transform.DEF, transform);
        await parseNode(child.Transform, transform);
      } else if (child.Group) {
        const group = new THREE.Group();
        parent.add(group);
        if (child.Group.DEF) defRegistry.set(child.Group.DEF, group);
        await parseNode(child.Group, group);
      } else if (child.Shape) {
        const shape = await createShape(child.Shape);
        if (shape) {
          parent.add(shape);
          if (child.Shape.DEF) defRegistry.set(child.Shape.DEF, shape);
        }
      } else if (child.Billboard) {
        const billboard = createBillboard(child.Billboard);
        parent.add(billboard);
        if (child.Billboard.DEF) defRegistry.set(child.Billboard.DEF, billboard);
        billboards.push(billboard);
        await parseNode(child.Billboard, billboard);
      } else if (child.PointLight) {
        const light = createPointLight(child.PointLight);
        parent.add(light);
        if (child.PointLight.DEF) defRegistry.set(child.PointLight.DEF, light);
      } else if (child.DirectionalLight) {
        const light = createDirectionalLight(child.DirectionalLight);
        parent.add(light);
        if (child.DirectionalLight.DEF) defRegistry.set(child.DirectionalLight.DEF, light);
      } else if (child.SpotLight) {
        const light = createSpotLight(child.SpotLight);
        parent.add(light);
        if (child.SpotLight.DEF) defRegistry.set(child.SpotLight.DEF, light);
      } else if (child.Background) {
        createBackground(child.Background, scene);
        if (child.Background.DEF) defRegistry.set(child.Background.DEF, scene.background);
      } else if (child.Fog) {
        createFog(child.Fog, scene);
      } else if (child.TimeSensor) {
        const sensor = createTimeSensor(child.TimeSensor);
        if (child.TimeSensor.DEF) defRegistry.set(child.TimeSensor.DEF, sensor);
        timeSensors.push(sensor);
      } else if (child.PositionInterpolator) {
        const interp = createPositionInterpolator(child.PositionInterpolator);
        if (child.PositionInterpolator.DEF) defRegistry.set(child.PositionInterpolator.DEF, interp);
        interpolators.push(interp);
      } else if (child.OrientationInterpolator) {
        const interp = createOrientationInterpolator(child.OrientationInterpolator);
        if (child.OrientationInterpolator.DEF) defRegistry.set(child.OrientationInterpolator.DEF, interp);
        interpolators.push(interp);
      } else if (child.ColorInterpolator) {
        const interp = createColorInterpolator(child.ColorInterpolator);
        if (child.ColorInterpolator.DEF) defRegistry.set(child.ColorInterpolator.DEF, interp);
        interpolators.push(interp);
      } else if (child.ScalarInterpolator) {
        const interp = createScalarInterpolator(child.ScalarInterpolator);
        if (child.ScalarInterpolator.DEF) defRegistry.set(child.ScalarInterpolator.DEF, interp);
        interpolators.push(interp);
      } else if (child.TouchSensor) {
        // Placeholder for touch sensor
        if (child.TouchSensor.DEF) defRegistry.set(child.TouchSensor.DEF, {});
      } else if (child.ROUTE) {
        routes.push(child.ROUTE);
      }
    };

    const createTransform = (transformData) => {
      const group = new THREE.Group();

      if (transformData.translation) {
        group.position.set(...transformData.translation);
      }

      if (transformData.rotation) {
        const [x, y, z, angle] = transformData.rotation;
        const axis = new THREE.Vector3(x, y, z).normalize();
        group.setRotationFromAxisAngle(axis, angle);
      }

      if (transformData.scale) {
        group.scale.set(...transformData.scale);
      }

      return group;
    };

    const createBillboard = (billboardData) => {
      const group = new THREE.Group();
      group.isBillboard = true;
      return group;
    };

    const createShape = async (shapeData) => {
      const geometry = await createGeometry(shapeData.geometry);
      const material = createMaterial(shapeData.appearance);

      if (geometry && material) {
        if (geometry.isLineGeometry) {
          return new THREE.LineSegments(geometry, material);
        } else if (geometry.isPointGeometry) {
          return new THREE.Points(geometry, material);
        } else {
          return new THREE.Mesh(geometry, material);
        }
      }
      return null;
    };

    const createGeometry = async (geometryData) => {
      if (!geometryData) return null;

      if (geometryData.Box) {
        const size = geometryData.Box.size || [1, 1, 1];
        return new THREE.BoxGeometry(...size);
      } else if (geometryData.Sphere) {
        const radius = geometryData.Sphere.radius || 1;
        return new THREE.SphereGeometry(radius, 32, 32);
      } else if (geometryData.Cone) {
        const radius = geometryData.Cone.bottomRadius || 1;
        const height = geometryData.Cone.height || 2;
        return new THREE.ConeGeometry(radius, height, 32);
      } else if (geometryData.Cylinder) {
        const radius = geometryData.Cylinder.radius || 1;
        const height = geometryData.Cylinder.height || 2;
        return new THREE.CylinderGeometry(radius, radius, height, 32);
      } else if (geometryData.Torus) {
        const outerRadius = geometryData.Torus.outerRadius || 1;
        const innerRadius = geometryData.Torus.innerRadius || 0.4;
        return new THREE.TorusGeometry(outerRadius, innerRadius, 16, 32);
      } else if (geometryData.IndexedFaceSet) {
        return createIndexedFaceSet(geometryData.IndexedFaceSet);
      } else if (geometryData.IndexedLineSet) {
        return createIndexedLineSet(geometryData.IndexedLineSet);
      } else if (geometryData.PointSet) {
        return createPointSet(geometryData.PointSet);
      } else if (geometryData.Text) {
        return await createTextGeometry(geometryData.Text);
      } else if (geometryData.ElevationGrid) {
        return createElevationGrid(geometryData.ElevationGrid);
      } else if (geometryData.Extrusion) {
        return createExtrusion(geometryData.Extrusion);
      }

      return null;
    };

    const createIndexedFaceSet = (ifsData) => {
      const geometry = new THREE.BufferGeometry();
      const points = ifsData.coord?.Coordinate?.point || [];
      const indices = ifsData.coordIndex || [];
      const colors = ifsData.color?.Color?.color || [];
      const colorIndex = ifsData.colorIndex || [];
      const colorPerVertex = ifsData.colorPerVertex !== false;

      // Parse indices (split by -1)
      const faces = [];
      let currentFace = [];
      for (const idx of indices) {
        if (idx === -1) {
          if (currentFace.length >= 3) {
            faces.push([...currentFace]);
          }
          currentFace = [];
        } else {
          currentFace.push(idx);
        }
      }

      // Convert to triangles
      const vertices = [];
      const vertexColors = [];

      faces.forEach((face, faceIdx) => {
        // Triangulate polygon (simple fan triangulation)
        for (let i = 1; i < face.length - 1; i++) {
          vertices.push(...points[face[0]], ...points[face[i]], ...points[face[i + 1]]);

          if (colors.length > 0) {
            if (colorPerVertex) {
              vertexColors.push(...colors[face[0]], ...colors[face[i]], ...colors[face[i + 1]]);
            } else {
              const colorIdx = colorIndex[faceIdx] !== undefined ? colorIndex[faceIdx] : faceIdx % colors.length;
              const color = colors[colorIdx] || [1, 1, 1];
              vertexColors.push(...color, ...color, ...color);
            }
          }
        }
      });

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      if (vertexColors.length > 0) {
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
      }
      geometry.computeVertexNormals();

      return geometry;
    };

    const createIndexedLineSet = (ilsData) => {
      const geometry = new THREE.BufferGeometry();
      const points = ilsData.coord?.Coordinate?.point || [];
      const indices = ilsData.coordIndex || [];
      const colors = ilsData.color?.Color?.color || [];

      const vertices = [];
      const vertexColors = [];
      let currentLine = [];

      for (const idx of indices) {
        if (idx === -1) {
          currentLine = [];
        } else {
          currentLine.push(idx);
          if (currentLine.length === 2) {
            vertices.push(...points[currentLine[0]], ...points[currentLine[1]]);
            if (colors.length > 0) {
              vertexColors.push(...(colors[currentLine[0]] || [1, 1, 1]));
              vertexColors.push(...(colors[currentLine[1]] || [1, 1, 1]));
            }
            currentLine.shift();
          }
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      if (vertexColors.length > 0) {
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
      }
      geometry.isLineGeometry = true;

      return geometry;
    };

    const createPointSet = (psData) => {
      const geometry = new THREE.BufferGeometry();
      const points = psData.coord?.Coordinate?.point || [];
      const colors = psData.color?.Color?.color || [];

      const vertices = points.flat();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

      if (colors.length > 0) {
        const vertexColors = colors.flat();
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
      }

      geometry.isPointGeometry = true;
      return geometry;
    };

    const createTextGeometry = async (textData) => {
      // Create simple text using sprites as fallback
      const strings = textData.string || ["Text"];
      const size = textData.fontStyle?.FontStyle?.size || 1;

      // Create a simple box geometry as placeholder for text
      // In a real implementation, you'd use TextGeometry with a loaded font
      const geometry = new THREE.BoxGeometry(strings[0].length * size * 0.5, size, 0.1);
      return geometry;
    };

    const createElevationGrid = (egData) => {
      const xDim = egData.xDimension || 2;
      const zDim = egData.zDimension || 2;
      const xSpacing = egData.xSpacing || 1;
      const zSpacing = egData.zSpacing || 1;
      const heights = egData.height || [];

      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];

      for (let z = 0; z < zDim; z++) {
        for (let x = 0; x < xDim; x++) {
          const height = heights[z * xDim + x] || 0;
          vertices.push(x * xSpacing, height, z * zSpacing);
        }
      }

      for (let z = 0; z < zDim - 1; z++) {
        for (let x = 0; x < xDim - 1; x++) {
          const a = z * xDim + x;
          const b = z * xDim + x + 1;
          const c = (z + 1) * xDim + x + 1;
          const d = (z + 1) * xDim + x;
          indices.push(a, b, d, b, c, d);
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return geometry;
    };

    const createExtrusion = (extData) => {
      const crossSection = extData.crossSection || [[1, 1], [1, -1], [-1, -1], [-1, 1], [1, 1]];
      const spine = extData.spine || [[0, 0, 0], [0, 1, 0]];
      const scales = extData.scale || spine.map(() => [1, 1]);

      const shape = new THREE.Shape();
      crossSection.forEach((point, i) => {
        if (i === 0) shape.moveTo(point[0], point[1]);
        else shape.lineTo(point[0], point[1]);
      });

      const extrudeSettings = {
        steps: spine.length - 1,
        depth: 1,
        bevelEnabled: false
      };

      return new THREE.ExtrudeGeometry(shape, extrudeSettings);
    };

    const createMaterial = (appearanceData) => {
      if (!appearanceData?.Appearance?.material?.Material) {
        return new THREE.MeshStandardMaterial({ color: 0x808080 });
      }

      const mat = appearanceData.Appearance.material.Material;
      const params = { vertexColors: false };

      if (mat.diffuseColor) {
        params.color = new THREE.Color(...mat.diffuseColor);
      }

      if (mat.emissiveColor) {
        params.emissive = new THREE.Color(...mat.emissiveColor);
      }

      if (mat.transparency !== undefined) {
        params.transparent = mat.transparency > 0;
        params.opacity = 1 - mat.transparency;
      }

      if (mat.shininess !== undefined) {
        params.roughness = 1 - mat.shininess;
        params.metalness = mat.shininess * 0.5;
      }

      // Store reference for animation
      const material = new THREE.MeshStandardMaterial(params);
      if (mat.DEF) {
        defRegistry.set(mat.DEF, material);
      }

      return material;
    };

    const createPointLight = (lightData) => {
      const color = lightData.color ? new THREE.Color(...lightData.color) : 0xffffff;
      const intensity = lightData.intensity !== undefined ? lightData.intensity : 1;
      const light = new THREE.PointLight(color, intensity);

      if (lightData.location) {
        light.position.set(...lightData.location);
      }

      return light;
    };

    const createDirectionalLight = (lightData) => {
      const color = lightData.color ? new THREE.Color(...lightData.color) : 0xffffff;
      const intensity = lightData.intensity !== undefined ? lightData.intensity : 1;
      const light = new THREE.DirectionalLight(color, intensity);

      if (lightData.direction) {
        const dir = new THREE.Vector3(...lightData.direction);
        light.position.copy(dir.negate().multiplyScalar(10));
      }

      return light;
    };

    const createSpotLight = (lightData) => {
      const color = lightData.color ? new THREE.Color(...lightData.color) : 0xffffff;
      const intensity = lightData.intensity !== undefined ? lightData.intensity : 1;
      const light = new THREE.SpotLight(color, intensity);

      if (lightData.location) {
        light.position.set(...lightData.location);
      }

      if (lightData.direction) {
        const target = new THREE.Object3D();
        const dir = new THREE.Vector3(...lightData.direction);
        target.position.copy(light.position).add(dir);
        light.target = target;
        scene.add(target);
      }

      if (lightData.angle !== undefined) {
        light.angle = lightData.angle;
      }

      return light;
    };

    const createBackground = (bgData, scene) => {
      if (bgData.skyColor && bgData.skyColor.length > 0) {
        scene.background = new THREE.Color(...bgData.skyColor[0]);
      }
    };

    const createFog = (fogData, scene) => {
      const color = fogData.color ? new THREE.Color(...fogData.color) : 0xffffff;
      const range = fogData.visibilityRange || 100;
      scene.fog = new THREE.Fog(color, range * 0.1, range);
    };

    const createTimeSensor = (sensorData) => {
      return {
        type: 'TimeSensor',
        cycleInterval: sensorData.cycleInterval || 1,
        loop: sensorData.loop !== false,
        enabled: sensorData.enabled !== false,
        fraction_changed: 0
      };
    };

    const createPositionInterpolator = (interpData) => {
      return {
        type: 'PositionInterpolator',
        key: interpData.key || [],
        keyValue: interpData.keyValue || [],
        value_changed: null,
        set_fraction: function(fraction) {
          this.value_changed = this.interpolate(fraction);
        },
        interpolate: function(fraction) {
          const keys = this.key;
          const values = this.keyValue;

          for (let i = 0; i < keys.length - 1; i++) {
            if (fraction >= keys[i] && fraction <= keys[i + 1]) {
              const t = (fraction - keys[i]) / (keys[i + 1] - keys[i]);
              const v1 = values[i];
              const v2 = values[i + 1];
              return [
                v1[0] + t * (v2[0] - v1[0]),
                v1[1] + t * (v2[1] - v1[1]),
                v1[2] + t * (v2[2] - v1[2])
              ];
            }
          }
          return values[0];
        }
      };
    };

    const createOrientationInterpolator = (interpData) => {
      return {
        type: 'OrientationInterpolator',
        key: interpData.key || [],
        keyValue: interpData.keyValue || [],
        value_changed: null,
        set_fraction: function(fraction) {
          this.value_changed = this.interpolate(fraction);
        },
        interpolate: function(fraction) {
          const keys = this.key;
          const values = this.keyValue;

          for (let i = 0; i < keys.length - 1; i++) {
            if (fraction >= keys[i] && fraction <= keys[i + 1]) {
              const t = (fraction - keys[i]) / (keys[i + 1] - keys[i]);
              const v1 = values[i];
              const v2 = values[i + 1];
              return [
                v1[0] + t * (v2[0] - v1[0]),
                v1[1] + t * (v2[1] - v1[1]),
                v1[2] + t * (v2[2] - v1[2]),
                v1[3] + t * (v2[3] - v1[3])
              ];
            }
          }
          return values[0];
        }
      };
    };

    const createColorInterpolator = (interpData) => {
      return {
        type: 'ColorInterpolator',
        key: interpData.key || [],
        keyValue: interpData.keyValue || [],
        value_changed: null,
        set_fraction: function(fraction) {
          this.value_changed = this.interpolate(fraction);
        },
        interpolate: function(fraction) {
          const keys = this.key;
          const values = this.keyValue;

          for (let i = 0; i < keys.length - 1; i++) {
            if (fraction >= keys[i] && fraction <= keys[i + 1]) {
              const t = (fraction - keys[i]) / (keys[i + 1] - keys[i]);
              const v1 = values[i];
              const v2 = values[i + 1];
              return [
                v1[0] + t * (v2[0] - v1[0]),
                v1[1] + t * (v2[1] - v1[1]),
                v1[2] + t * (v2[2] - v1[2])
              ];
            }
          }
          return values[0];
        }
      };
    };

    const createScalarInterpolator = (interpData) => {
      return {
        type: 'ScalarInterpolator',
        key: interpData.key || [],
        keyValue: interpData.keyValue || [],
        value_changed: null,
        set_fraction: function(fraction) {
          this.value_changed = this.interpolate(fraction);
        },
        interpolate: function(fraction) {
          const keys = this.key;
          const values = this.keyValue;

          for (let i = 0; i < keys.length - 1; i++) {
            if (fraction >= keys[i] && fraction <= keys[i + 1]) {
              const t = (fraction - keys[i]) / (keys[i + 1] - keys[i]);
              return values[i] + t * (values[i + 1] - values[i]);
            }
          }
          return values[0];
        }
      };
    };

    const processRoutes = () => {
      routes.forEach(route => {
        const fromNode = defRegistry.get(route.fromNode);
        const toNode = defRegistry.get(route.toNode);

        if (!fromNode || !toNode) return;

        // Create animation connection function
        const updateFn = () => {
          // 1. Transfer fraction from TimeSensor -> Interpolator
          if (fromNode.fraction_changed !== undefined) {
            if (route.toField === 'set_fraction' && toNode.set_fraction) {
              toNode.set_fraction(fromNode.fraction_changed);
            }
          }

          // 2. Transfer value from Interpolator -> Target Node
          if (toNode.value_changed !== undefined && toNode.value_changed !== null) {
            if (route.toField === 'set_translation') {
              toNode.position.set(...toNode.value_changed);
            } else if (route.toField === 'set_rotation') {
              const [x, y, z, angle] = toNode.value_changed;
              const axis = new THREE.Vector3(x, y, z).normalize();
              toNode.setRotationFromAxisAngle(axis, angle);
            } else if (route.toField === 'set_diffuseColor') {
              toNode.color.setRGB(...toNode.value_changed);
            } else if (route.toField === 'set_scale') {
              toNode.scale.set(...toNode.value_changed);
            }
          }
        };

        // Add to update loop
        routeUpdates.push(updateFn);
      });
    };

    init();
  }, [jsonInput]);

  const handleLoadJSON = () => {
    try {
      JSON.parse(jsonInput);
      // Force re-mount of renderer
      const currentInput = jsonInput;
      setJsonInput('');
      setTimeout(() => setJsonInput(currentInput), 10);
    } catch (err) {
      setError(`Invalid JSON: ${err.message}`);
    }
  };

  return (
    <div className="w-full h-screen bg-gray-900 flex flex-col">
      <div className="bg-gradient-to-r from-indigo-900 to-purple-900 p-4 border-b border-purple-700">
        <h1 className="text-3xl font-bold text-white mb-2">Complete X3D JSON Renderer</h1>
        <p className="text-purple-200 text-sm">WebGPU + Three.js ‚Ä¢ Full X3D Node Support with Animation & Routing</p>
      </div>

      {error && (
        <div className="bg-red-900 text-red-200 p-4 m-4 rounded border border-red-700">
          <strong>Error:</strong> {error}
        </div>
      )}

      {loading && (
        <div className="bg-blue-900 text-blue-200 p-4 m-4 rounded border border-blue-700">
          Loading renderer...
        </div>
      )}

      <div className="flex flex-1 overflow-hidden">
        <div className="w-1/3 bg-gray-800 p-4 overflow-auto border-r border-gray-700">
          <h2 className="text-white font-semibold mb-2 text-lg">X3D JSON Scene</h2>
          <textarea
            className="w-full h-96 bg-gray-900 text-gray-200 p-3 rounded font-mono text-xs border border-gray-700 focus:border-purple-500 focus:outline-none"
            value={jsonInput}
            onChange={(e) => setJsonInput(e.target.value)}
            spellCheck={false}
          />
          <button
            onClick={handleLoadJSON}
            className="mt-3 w-full bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white px-4 py-3 rounded font-semibold transition-all"
          >
            üîÑ Reload Scene
          </button>

          <div className="mt-4 text-gray-300 text-xs space-y-2">
            <h3 className="text-white font-semibold text-sm mb-2">‚ú® Supported Features:</h3>

            <div className="bg-gray-900 p-3 rounded">
              <div className="font-semibold text-purple-300 mb-1">üé® Geometry</div>
              <div className="text-gray-400">Box, Sphere, Cone, Cylinder, Torus, IndexedFaceSet, IndexedLineSet, PointSet, Text, ElevationGrid, Extrusion</div>
            </div>

            <div className="bg-gray-900 p-3 rounded">
              <div className="font-semibold text-purple-300 mb-1">üí° Lighting</div>
              <div className="text-gray-400">DirectionalLight, PointLight, SpotLight</div>
            </div>

            <div className="bg-gray-900 p-3 rounded">
              <div className="font-semibold text-purple-300 mb-1">üé¨ Animation</div>
              <div className="text-gray-400">TimeSensor, PositionInterpolator, OrientationInterpolator, ColorInterpolator, ScalarInterpolator, ROUTE</div>
            </div>

            <div className="bg-gray-900 p-3 rounded">
              <div className="font-semibold text-purple-300 mb-1">üåç Environment</div>
              <div className="text-gray-400">Background, Fog, Billboard</div>
            </div>

            <div className="bg-gray-900 p-3 rounded">
              <div className="font-semibold text-purple-300 mb-1">üéØ Organization</div>
              <div className="text-gray-400">Transform, Group, DEF/USE naming</div>
            </div>
          </div>
        </div>

        <div className="flex-1 relative bg-black">
          <div ref={containerRef} className="w-full h-full" />
          <div className="absolute bottom-4 left-4 bg-black bg-opacity-75 text-white p-3 rounded-lg text-xs space-y-1 border border-gray-700">
            <div className="font-bold text-purple-300 mb-2">üéÆ Controls</div>
            <div>üñ±Ô∏è Left Click + Drag = Rotate</div>
            <div>üñ±Ô∏è Right Click + Drag = Pan</div>
            <div>üñ±Ô∏è Scroll = Zoom</div>
          </div>

          <div className="absolute top-4 right-4 bg-black bg-opacity-75 text-white p-3 rounded-lg text-xs border border-gray-700">
            <div className="font-bold text-green-300">‚ö° WebGPU Active</div>
          </div>
        </div>
      </div>
    </div>
  );
}
