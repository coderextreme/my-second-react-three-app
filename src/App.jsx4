import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
// Import WebGPURenderer explicitly from the webgpu path
import { WebGPURenderer } from 'three/webgpu';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import WebGPU from 'three/addons/capabilities/WebGPU.js';

export default function App() {
  const containerRef = useRef(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [jsonInput, setJsonInput] = useState('');

  // Default comprehensive scene
  const defaultScene = {
    "X3D": {
      "version": "3.3",
      "profile": "Immersive",
      "Scene": {
        "children": [
          { "Background": { "skyColor": [[0.0, 0.2, 0.7], [0.0, 0.5, 1.0], [1.0, 1.0, 1.0]], "skyAngle": [1.309, 1.571] } },
          { "DirectionalLight": { "direction": [0, -1, -1], "intensity": 0.8 } },
          { "PointLight": { "location": [5, 3, 5], "color": [1, 0.2, 0.2], "intensity": 0.6 } },
          { "SpotLight": { "location": [-5, 5, 5], "direction": [1, -1, -1], "intensity": 0.7 } },
          {
            "Transform": {
              "DEF": "BoxTransform",
              "translation": [-8, 1, 0],
              "children": [
                { "Shape": { "geometry": { "Box": { "size": [2, 2, 2] } }, "appearance": { "Appearance": { "material": { "Material": { "DEF": "RedMaterial", "diffuseColor": [1, 0.2, 0.2] } } } } } }
              ]
            }
          },
          { "Transform": { "translation": [0, 1, 0], "children": [{ "Shape": { "geometry": { "Cone": { "height": 3, "bottomRadius": 1.5 } }, "appearance": { "Appearance": { "material": { "Material": { "diffuseColor": [0.2, 0.2, 1] } } } } } }] } },
          { "Transform": { "translation": [8, 1, 0], "children": [{ "Shape": { "geometry": { "Torus": { "outerRadius": 1.5, "innerRadius": 0.5 } }, "appearance": { "Appearance": { "material": { "Material": { "diffuseColor": [1, 0.5, 0.2] } } } } } }] } },
          { "TimeSensor": { "DEF": "Clock", "cycleInterval": 5, "loop": true } },
          { "PositionInterpolator": { "DEF": "BoxMover", "key": [0, 0.5, 1], "keyValue": [[-8, 1, 0], [-8, 3, 0], [-8, 1, 0]] } },
          { "ROUTE": { "fromNode": "Clock", "fromField": "fraction_changed", "toNode": "BoxMover", "toField": "set_fraction" } },
          { "ROUTE": { "fromNode": "BoxMover", "fromField": "value_changed", "toNode": "BoxTransform", "toField": "set_translation" } }
        ]
      }
    }
  };

  useEffect(() => {
    setJsonInput(JSON.stringify(defaultScene, null, 2));
  }, []);

  useEffect(() => {
    if (!jsonInput) return;

    // Check WebGPU support safely
    if (WebGPU && !WebGPU.isAvailable()) {
      setError('WebGPU is not supported in this browser.');
      setLoading(false);
      return;
    }

    let renderer, scene, camera, controls, clock;
    let resizeObserver;
    const defRegistry = new Map();
    const routes = [];
    const timeSensors = [];
    const routeUpdates = [];
    const billboards = [];

    const init = async () => {
      try {
        setLoading(true);

        // 1. Setup Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        clock = new THREE.Clock();

        const width = containerRef.current.clientWidth;
        const height = containerRef.current.clientHeight;

        camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
        camera.position.set(0, 5, 20);

        // 2. Setup WebGPU Renderer
        renderer = new WebGPURenderer({ antialias: true });
        await renderer.init(); // Wait for WebGPU backend to initialize

        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);

        containerRef.current.innerHTML = '';
        containerRef.current.appendChild(renderer.domElement);

        // 3. Setup Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 4. Parse X3D
        const x3dData = JSON.parse(jsonInput);
        await parseX3DJSON(x3dData, scene);
        processRoutes();

        // 5. Animation Loop
        const animate = () => {
          const elapsedTime = clock.getElapsedTime();

          // Update TimeSensors
          timeSensors.forEach(sensor => {
            if (sensor.enabled && sensor.loop) {
              sensor.fraction_changed = (elapsedTime % sensor.cycleInterval) / sensor.cycleInterval;
            }
          });

          // Run Route updates
          routeUpdates.forEach(fn => fn());

          // Update Billboards
          billboards.forEach(b => b.lookAt(camera.position));

          controls.update();
          renderer.render(scene, camera);
        };

        renderer.setAnimationLoop(animate);

        // 6. Robust Resize Handling
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const { width, height } = entry.contentRect;
            if (width > 0 && height > 0) {
              camera.aspect = width / height;
              camera.updateProjectionMatrix();
              renderer.setSize(width, height);
            }
          }
        });
        resizeObserver.observe(containerRef.current);

        setLoading(false);
      } catch (err) {
        console.error(err);
        setError(err.message);
        setLoading(false);
      }
    };

    // --- Parsing Logic ---
    const parseX3DJSON = async (data, parent) => {
      if (data.X3D?.Scene) await parseNode(data.X3D.Scene, parent);
    };

    const parseNode = async (node, parent) => {
      if (node.children) {
        for (const child of node.children) await parseChild(child, parent);
      }
    };

    const parseChild = async (child, parent) => {
      // Helper to extract DEF name
      const getDef = (obj) => obj.DEF || Object.values(obj)[0]?.DEF;
      const defName = getDef(child);
      let object = null;

      if (child.Transform) {
        object = createTransform(child.Transform);
        await parseNode(child.Transform, object);
      } else if (child.Group) {
        object = new THREE.Group();
        await parseNode(child.Group, object);
      } else if (child.Shape) {
        object = await createShape(child.Shape);
      } else if (child.DirectionalLight) {
        const { color, intensity, direction } = child.DirectionalLight;
        object = new THREE.DirectionalLight(new THREE.Color(...(color || [1,1,1])), intensity || 1);
        if (direction) object.position.copy(new THREE.Vector3(...direction).negate().multiplyScalar(10));
      } else if (child.PointLight) {
        const { color, intensity, location } = child.PointLight;
        object = new THREE.PointLight(new THREE.Color(...(color || [1,1,1])), intensity || 1);
        if (location) object.position.set(...location);
      } else if (child.Background) {
        if (child.Background.skyColor) scene.background = new THREE.Color(...child.Background.skyColor[0]);
        if (defName) defRegistry.set(defName, scene.background);
      } else if (child.TimeSensor) {
        const sensor = { ...child.TimeSensor, fraction_changed: 0, enabled: true, loop: true };
        timeSensors.push(sensor);
        if (defName) defRegistry.set(defName, sensor);
      } else if (child.PositionInterpolator) {
        const pi = createInterpolator(child.PositionInterpolator, 3);
        if (defName) defRegistry.set(defName, pi);
      } else if (child.ROUTE) {
        routes.push(child.ROUTE);
      }

      if (object) {
        parent.add(object);
        if (defName) defRegistry.set(defName, object);
      }
    };

    const createTransform = (data) => {
      const group = new THREE.Group();
      if (data.translation) group.position.set(...data.translation);
      if (data.rotation) {
        const [x, y, z, angle] = data.rotation;
        group.setRotationFromAxisAngle(new THREE.Vector3(x,y,z).normalize(), angle);
      }
      return group;
    };

    const createShape = async (data) => {
      let geo, mat;
      if (data.geometry?.Box) geo = new THREE.BoxGeometry(...(data.geometry.Box.size || [1,1,1]));
      else if (data.geometry?.Sphere) geo = new THREE.SphereGeometry(data.geometry.Sphere.radius || 1);
      else if (data.geometry?.Cone) geo = new THREE.ConeGeometry(data.geometry.Cone.bottomRadius || 1, data.geometry.Cone.height || 2);
      else if (data.geometry?.Torus) geo = new THREE.TorusGeometry(data.geometry.Torus.outerRadius || 1, data.geometry.Torus.innerRadius || 0.5);

      if (data.appearance?.Appearance?.material?.Material) {
        const m = data.appearance.Appearance.material.Material;
        mat = new THREE.MeshStandardMaterial({
          color: m.diffuseColor ? new THREE.Color(...m.diffuseColor) : 0xffffff
        });
        if (m.DEF) defRegistry.set(m.DEF, mat);
      } else {
        mat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      }

      return geo ? new THREE.Mesh(geo, mat) : null;
    };

    const createInterpolator = (data, dims) => ({
      key: data.key,
      keyValue: data.keyValue,
      value_changed: null,
      set_fraction: function(f) {
        // Simple linear interpolation logic
        for(let i=0; i<this.key.length-1; i++) {
          if (f >= this.key[i] && f <= this.key[i+1]) {
            const t = (f - this.key[i]) / (this.key[i+1] - this.key[i]);
            const v1 = this.keyValue[i];
            const v2 = this.keyValue[i+1];
            this.value_changed = v1.map((v, idx) => v + t * (v2[idx] - v));
            return;
          }
        }
      }
    });

    const processRoutes = () => {
      routes.forEach(r => {
        const from = defRegistry.get(r.fromNode);
        const to = defRegistry.get(r.toNode);
        if (from && to) {
          routeUpdates.push(() => {
            if (from.fraction_changed !== undefined && to.set_fraction) {
              to.set_fraction(from.fraction_changed);
            }
            if (to.value_changed) {
              if (r.toField === 'set_translation') to.position.set(...to.value_changed);
              // Add other field handlers here
            }
          });
        }
      });
    };

    init();

    return () => {
      if (resizeObserver) resizeObserver.disconnect();
      if (renderer) {
        renderer.setAnimationLoop(null);
        try { renderer.dispose(); } catch(e){}
      }
    };
  }, [jsonInput]);

  const handleLoad = () => {
    const tmp = jsonInput; setJsonInput(''); setTimeout(() => setJsonInput(tmp), 10);
  };

  return (
    <div className="w-full h-screen bg-gray-900 flex flex-col">
      <div className="bg-gradient-to-r from-indigo-900 to-purple-900 p-4 border-b border-purple-700">
        <h1 className="text-xl font-bold text-white">X3D WebGPU Renderer</h1>
      </div>

      {error && <div className="bg-red-900 text-white p-2">{error}</div>}

      <div className="flex flex-1 overflow-hidden">
        <div className="w-1/3 bg-gray-800 p-4 flex flex-col border-r border-gray-700">
          <textarea
            className="flex-1 bg-gray-900 text-gray-200 p-2 font-mono text-xs mb-2 resize-none"
            value={jsonInput} onChange={e => setJsonInput(e.target.value)}
          />
          <button onClick={handleLoad} className="bg-purple-600 text-white p-2 rounded">Reload</button>
        </div>

        {/* The Container for Three.js */}
        <div className="flex-1 bg-black relative">
          <div ref={containerRef} className="absolute inset-0 w-full h-full" />
          <div className="absolute top-4 right-4 text-green-500 font-mono text-xs">WebGPU Active</div>
        </div>
      </div>
    </div>
  );
}
